{
    parserClass="com.github.andreypfau.intellijton.func.parser.FuncParser"
    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="Func"
    psiImplClassSuffix="Impl"
    psiPackage="com.github.andreypfau.intellijton.func.psi"
    psiImplPackage="com.github.andreypfau.intellijton.func.psi.impl"
    implements="com.github.andreypfau.intellijton.func.psi.FuncElement"

    elementTypeHolderClass="com.github.andreypfau.intellijton.func.psi.FuncTypes"
    elementTypeClass="com.github.andreypfau.intellijton.func.psi.FuncElementType"
    tokenTypeClass="com.github.andreypfau.intellijton.func.psi.FuncTokenType"

    tokens = [
        COMMENT='regexp:(;;.*)|(\{-[\s\S]*?-})'
        stringLiteral='regexp:("([^"\r\n\\]|\\.)*")|unicode("([^"])*")'
        decimalNumber='regexp:([0-9][_0-9]*)'
        fixedNumber='regexp:(([0-9][_0-9]*)+\.[_0-9]*|([0-9][_0-9]*)*\.([0-9][_0-9]*))'
        scientificNumber='regexp:((([0-9][_0-9]*)+|([0-9][_0-9]*)+\.[_0-9]*|([0-9][_0-9]*|[0-9])*\.[_0-9]+)[Ee][+-]?[_0-9]+)'
        hexNumber='regexp:(0[xX][_0-9a-fA-F]+)'
        booleanLiteral='regexp:true|false'
        space='regexp:\s+'

        IDENTIFIER='regexp:[a-zA-Z_$][a-zA-Z_$0-9]*'

        SEMICOLON=';'
        COMMA=','
        PLUS='+'
        MINUS='-'
        MULT='*'
        DIV='/'
        EXPONENT='**'
        NOT='!'
        ASSIGN='='
        TO='=>'
        EQ='=='
        NEQ='!='
        INC='++'
        DEC='--'
        PLUS_ASSIGN='+='
        MINUS_ASSIGN='-='
        MULT_ASSIGN='*='
        DIV_ASSIGN='/='
        OR_ASSIGN='|='
        XOR_ASSIGN='^='
        AND_ASSIGN='&='
        LSHIFT_ASSIGN='<<='
        RSHIFT_ASSIGN='>>='
        PERCENT_ASSIGN='%='
        LESS='<'
        LESSEQ='<='
        MORE='>'
        MOREEQ='>='
        CARET='^'
        AND='&'
        ANDAND='&&'
        OR='|'
        OROR='||'
        LBRACKET='['
        RBRACKET=']'
        LBRACE='{'
        RBRACE='}'
        LPAREN='('
        RPAREN=')'
    ]

    extends(".*Expression")=Expression
    extends(".*TypeName")=TypeName
}

SourceUnit ::= (
        FunctionDefinition
        | ConstantVariableDeclaration
        | Expression
    )*
private UntilSemicolonRecover ::= !(';')
private UntilBraceRecover ::= !('}')

ConstantIdentifier ::= IDENTIFIER
ConstantVariableDeclaration ::= 'global' TypeName ConstantIdentifier ('=' Expression)? ';'

ReturnDef ::=
        TypeName |
        '(' ( TypeName (',' TypeName)* )? ')' |
        '[' ( TypeName (',' TypeName)* )? ']' |
        '_'

ParameterIdentifier ::= IDENTIFIER
ParameterDef ::= TypeName ParameterIdentifier?
ParameterList ::= '(' ( ParameterDef (',' ParameterDef)* )? ')'

FunctionIdentifier ::= IDENTIFIER
FunctionDefinition ::= ReturnDef FunctionIdentifier ParameterList FunctionSpecifiers* ( ';' | Block ) {
    pin = 2
    mixin = "com.github.andreypfau.intellijton.func.psi.FuncFunctionDefinitionMixin"
    implements = "com.github.andreypfau.intellijton.func.psi.FuncNamedElement"
}

DeclarationIdentifier ::= IDENTIFIER
DeclarationItem ::= DeclarationIdentifier ','? | ','
DeclarationList ::= '(' DeclarationItem*    ')'
TypedDeclarationItem ::= (TypeName)? DeclarationIdentifier ','? | ','
TypedDeclarationList ::= '(' TypedDeclarationItem*    ')'

TypedItem ::= TypeName ','? | ','
TypedList ::= '(' TypedItem* ')'

VariableIdentifier ::= IDENTIFIER
VariableDeclaration ::=
        DeclarationList |
        TypedDeclarationList |
        TypedList VariableIdentifier |
        TypeName VariableIdentifier

TypeName ::=    PrimitiveTypeName

FunctionSpecifiers ::= impure | inline | inline_ref | method_id

private UnfinishedBlock ::= '{' (Statement)* {
        pin = 1
        recoverWhile = UntilBraceRecover
}
Block ::= UnfinishedBlock '}'

private FinishedStatement ::=
    DoUntilStatement
    | ReturnSt
    | SimpleStatement {
    recoverWhile = UntilSemicolonRecover
}
Statement ::= IfStatement | IfNotStatement | WhileStatement | RepeatStatement | Block | ReturnTupleStatement | FinishedStatement ';'

ReturnTupleStatement ::= return SeqExpression ';'

private ExpressionStatement ::= Expression
IfStatement ::= if '(' Expression ')' Block ( else Block )? {pin=1}
IfNotStatement ::= ifnot '(' Expression ')' Block ( else Block )? {pin=1}
WhileStatement ::= while '(' Expression ')' Block {pin=1}
RepeatStatement ::= repeat '(' Expression ')' Block {pin=1}
private SimpleStatement ::= VariableDefinition | ExpressionStatement
DoUntilStatement ::= do Block until '(' Expression ')' {pin=1}
ReturnSt ::= return Expression? {pin=1}
SeqExpression ::= '(' (Expression ',')* Expression? ','* ')'
VariableDefinition ::= VariableDeclaration ( '=' Expression | SeqExpression )?

Expression ::=
    TernaryExpression
    | OrExpression
    | AndExpression
    | CompExpression
    | OrOpExpression
    | XorOpExpression
    | AndOpExpression
    | EqExpression
    | ShiftExpression
    | MultDivExpression
    | HighestPriorityGroup
    | AssignmentExpression
    | PlusMinExpression
    | InlineArrayExpression
    | PrimaryExpression {

    }

private HighestPriorityGroup ::=
    IndexAccessExpression
    | MemberAccessExpression
    | ModifierAccessExpression
    | FunctionCallExpression
    | SeqExpression

AssignmentExpression ::= Expression ('=' | '|=' | '^=' | '&=' | '<<=' | '>>=' | '+=' | '-=' | '*=' | '/=' | '%=') Expression
InlineArrayExpression ::= '[' Expression (',' Expression)* ']'
TernaryExpression ::= Expression '?' RightTernaryExpression
private RightTernaryExpression ::= Expression ':' Expression
OrExpression ::= Expression '||' Expression
AndExpression ::= Expression '&&' Expression
EqExpression ::= Expression ('==' | '!=') Expression
CompExpression ::= Expression ('<' | '>' | '<=' | '>=') Expression
OrOpExpression ::= Expression '|' Expression
XorOpExpression ::= Expression '^' Expression
AndOpExpression ::= Expression '&' Expression
ShiftExpression ::= Expression ('<<' | '>>') Expression
PlusMinExpression ::= Expression ('+' | '-') Expression
MultDivExpression ::= Expression ('*' | '/' | '%') Expression

PrimaryExpression ::= VarLiteral
    | BooleanLiteral
    | NumberLiteral
    | HexLiteral
    | StringLiteral
    | PrimitiveTypeNameExpression

VarLiteral ::= IDENTIFIER {
    mixin = "com.github.andreypfau.intellijton.func.psi.FuncVarLiteralMixin"
}
FunctionCallExpression ::= Expression FunctionInvocation {
    mixin = 'com.github.andreypfau.intellijton.func.psi.FuncFunctionCallMixin'
}
private FunctionInvocation ::= '(' FunctionCallArguments? ')'
FunctionCallArguments ::= Expression? ( ',' Expression )*
MemberAccessIdentifier ::= IDENTIFIER
MemberAccessExpression ::= Expression '.' MemberAccessIdentifier
ModifierAccessIdentifier ::= IDENTIFIER
ModifierAccessExpression ::= Expression '~' ModifierAccessIdentifier
IndexAccessExpression ::= Expression '[' ( Expression? ':' Expression? | Expression? ) ']' {pin=2}

BooleanLiteral ::= booleanLiteral
NumberLiteral ::= ( HexNumber | DecimalNumber | FixedNumber | ScientificNumber)
private HexLiteral ::= hexLiteral
private StringLiteral ::= stringLiteral
private HexNumber ::= hexNumber
private FixedNumber ::= fixedNumber
private DecimalNumber ::= decimalNumber
private ScientificNumber ::= scientificNumber

private PrimitiveTypeNameExpression ::= PrimitiveTypeName
PrimitiveTypeName ::= int | cell | slice | builder | tuple | cont | var
