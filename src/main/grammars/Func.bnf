{
    parserClass="com.github.andreypfau.intellijton.func.parser.FuncParser"
    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="Func"
    psiImplClassSuffix="Impl"
    psiPackage="com.github.andreypfau.intellijton.func.psi"
    psiImplPackage="com.github.andreypfau.intellijton.func.psi.impl"
    implements="com.github.andreypfau.intellijton.func.psi.FuncElement"

    elementTypeHolderClass="com.github.andreypfau.intellijton.func.psi.FuncTypes"
    elementTypeClass="com.github.andreypfau.intellijton.func.psi.FuncElementType"
    tokenTypeClass="com.github.andreypfau.intellijton.func.psi.FuncTokenType"

    tokens = [
        RETURN='return'
        REPEAT='repeat'
        IF='if'
        IFNOT='ifnot'
        ELSEIF='elseif'
        ELSEIFNOT='elseifnot'
        ELSE='else'
        WHILE='while'
        DO='do'
        UNTIL='until'
        FORALL='forall'
        IMPURE='impure'
        INLINE='inline'
        INLINE_REF='inline_ref'
        METHOD_ID='method_id'
        ASM='asm'
        GLOBAL='global'
        VAR='var'
        INT='int'
        CELL='cell'
        SLICE='slice'
        BUILDER='builder'
        CONT='cont'
        TUPLE='tuple'
        TYPE='type'
        TRUE='true'
        FALSE='false'
        DECIMNAL_NUMBER_LITERAL='regexp:([0-9][_0-9]*)'
        HEX_NUMBER_LITERAL='regexp:(0[xX][_0-9a-fA-F]+)'
        BINARY_NUMBER_LITERAL='regexp:(0[bB][_0-1]+)'
        STRING_LITERAL='regexp:("([^"\r\n\\]|\\.)*")|unicode("([^"])*")'
        IDENTIFIER="regexp:(`.*`)|(([a-zA-Z_](\w|['?:])+)|([a-zA-Z]))"
        SPACE='regexp:\s+'
        COMMENT='regexp:(;;.*)|(\{-[\s\S]*?-})'
        SEMICOLON=';'
        COMMA=','
        PLUS='+'
        MINUS='-'
        MULT='*'
        DIV='/'
        NOT='!'
        ASSIGN='='
        PLUS_ASSIGN='+='
        MINUS_ASSIGN='-='
        MULT_ASSIGN='*='
        DIV_ASSIGN='/='
        EQUALS='=='
        LESS='<'
        GREATER='>'
        LESS_EQUALS='<='
        GREATER_EQUALS='>='
        NOT_EQUALS='!='
        IN_RANGE='<=>'
        LBRACKET='['
        RBRACKET=']'
        LBRACE='{'
        RBRACE='}'
        LPAREN='('
        RPAREN=')'
        UNDERSCORE='_'
        ARROW='->'
        DOT='.'
        TILDA='~'
    ]
}

private root ::= (function_definition | global_var_declarations)*
function_definition ::= (type_variables_list)? type function_name parameter_list 'impure'? inline_specifier? method_id_specifier? (';' | block_statement | asm_function_body)

type_variables_list ::= 'forall' (('type')? type_identifier (',' ('type')? type_identifier)*)? '->' {pin=1}
inline_specifier ::= ('inline' | 'inline_ref')
method_id_specifier ::= 'method_id' ('(' number_literal ')')? {pin=1}

asm_function_body ::= asm_specifier (asm_instruction)+ ';'
asm_specifier ::= 'asm' ('(' (IDENTIFIER)* ('->' (number_literal)*)? ')')? {pin=1}
asm_instruction ::= STRING_LITERAL

parameter_list ::= '(' parameter_list_element* ')'
private parameter_list_element ::= !(')') parameter_declaration (',' | &')') { pin=2 }
parameter_declaration ::= (type)? (IDENTIFIER | '_')

global_var_declarations ::= 'global' global_var_declaration (',' global_var_declaration)* ';' {pin=1}
private global_var_declaration ::= (type)? IDENTIFIER

//
// STATEMENTS
//

private statement ::= (return_statement | block_statement | empty_statement | repeat_statement | if_statement | do_statement | while_statement | expression_statement)

private block_statement_recovery ::= !('}')
private block_statement_element ::= !('}') statement* { recoverWhile=block_statement_recovery }
block_statement ::= '{' (block_statement_element)* '}'

return_statement ::= 'return' expression ';' {pin=1}
expression_statement ::= expression ';' {pin=1}
empty_statement ::= ';'
repeat_statement ::= 'repeat' expression block_statement {pin=1}
if_statement ::= ('if' | 'ifnot') expression block_statement (else_statement|elseif_statement|elseifnot_statement)? {pin=1}
elseif_statement ::= 'elseif' expression block_statement (elseifnot_statement|else_statement)? {pin=1}
elseifnot_statement ::= 'elseifnot' expression block_statement (else_statement)? {pin=1}
else_statement ::= 'else' block_statement {pin=1}
do_statement ::= 'do' block_statement 'until' expression {pin=1}
while_statement ::= 'while' expression block_statement {pin=1}

//
// EXPRESSIONS
//

private expression ::= expr10
private expr10 ::= expr13 (('=' | '+=' | '-=' | '*=' | '/=' | '~/=' | '^/=' | '%=' | '~%=' | '^%=' | '<<=' | '>>=' | '~>>=' | '^>>=' | '&=' | '|=' | '^=') expr10)?
private expr13 ::= expr15 ('?' expression ':' expr13)?
private expr15 ::= expr17 (('==' | '<' | '>' | '<=' | '>=' | '!=' | '<=>') expr17)?
private expr17 ::= expr20 (('<<' | '>>' | '~>>' | '^>>') expr20)*
private expr20 ::= ('-')? expr30 (('-' | '+' | '|' | '^') expr30)*
private expr30 ::= expr75 (('*' | '/' | '%' | '~/' | '^/' | '~%' | '^%' | '/%' | '&') expr75)*
private expr75 ::= ('~')? expr80
private expr80 ::= expr90 (method_call)*
private expr90 ::= (variable_declaration | function_application | expr100)
private expr100 ::= (type_expression | nontype_expr100)
private nontype_expr100 ::= (parenthesized_expression | tensor_expression | tuple_expression | unit_literal | primitive_type | number_literal | boolean_literal | '_' | IDENTIFIER)

method_call ::= ('.' | '~') IDENTIFIER expr100 {pin=1}

variable_declaration ::= type_expression (IDENTIFIER | tuple_expression | tensor_expression | parenthesized_expression)
function_application ::= nontype_expr100 ((IDENTIFIER | parenthesized_expression | tensor_expression | unit_literal))+

type_expression ::= (primitive_type | 'type' | var_type | parenthesized_type_expression | tensor_type_expression | tuple_type_expression)
parenthesized_type_expression ::= '(' type_expression ')'
private tensor_type_expression_element ::= !')' type_expression (','|&')') {pin=2}
tensor_type_expression ::= '(' tensor_type_expression_element+ ')'
private tuple_type_expression_element ::= !')' type_expression (','|&')') {pin=2}
tuple_type_expression ::= '[' tuple_type_expression_element+ ']'

parenthesized_expression ::= '(' expression ')'
private tensor_expression_element ::= !')' expression (','|&')') {pin=2}
tensor_expression ::= '(' tensor_expression_element+ ')'
private tuple_expression_element ::= !')' expression (','|&')') {pin=2}
tuple_expression ::= '[' tuple_expression_element+ ']'

//
// TYPES
//

private type ::= (function_type | atomic_type)
private atomic_type ::= (primitive_type | var_type | hole_type | type_identifier | unit_type | tensor_type | tuple_type)
primitive_type ::= ('int' | 'cell' | 'slice' | 'builder' | 'cont' | 'tuple')
var_type ::= 'var'
hole_type ::= '_'
type_identifier ::= IDENTIFIER
private tensor_type_element ::= !')' type (','|&')') {pin=2}
tensor_type ::= '(' tensor_type_element* ')'
unit_type ::= unit_literal
private tuple_type_element ::= !'[' type (','|&']') {pin=2}
tuple_type ::= '[' tuple_type_element* ']'
function_type ::= atomic_type '->' type {pin=2}

//
// LITERALS
//

boolean_literal ::= TRUE | FALSE
number_literal ::= DECIMNAL_NUMBER_LITERAL | HEX_NUMBER_LITERAL | BINARY_NUMBER_LITERAL
function_name ::= IDENTIFIER
unit_literal ::= '(' ')'