{
    parserClass="com.github.andreypfau.intellijton.func.parser.FuncParser"
    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="Func"
    psiImplClassSuffix="Impl"
    psiPackage="com.github.andreypfau.intellijton.func.psi"
    psiImplPackage="com.github.andreypfau.intellijton.func.psi.impl"
    implements="com.github.andreypfau.intellijton.func.psi.FuncElement"

    elementTypeHolderClass="com.github.andreypfau.intellijton.func.psi.FuncTypes"
    elementTypeClass="com.github.andreypfau.intellijton.func.psi.FuncElementType"
    tokenTypeClass="com.github.andreypfau.intellijton.func.psi.FuncTokenType"

    tokens = [
        COMMENT='regexp:(;;.*)|(\{-[\s\S]*?-})'
        stringLiteral='regexp:("([^"\r\n\\]|\\.)*")|unicode("([^"])*")'
        decimalNumber='regexp:([0-9][_0-9]*)'
        hexNumber='regexp:(0[xX][_0-9a-fA-F]+)'
        hexNumber='regexp:(0[bB][_0-1]+)'
        booleanLiteral='regexp:true|false'
        space='regexp:\s+'

        IDENTIFIER='regexp:[a-zA-Z_$][a-zA-Z_$0-9:?]*'
        ASM='asm'
        SEMICOLON=';'
        COMMA=','
        PLUS='+'
        MINUS='-'
        MULT='*'
        DIV='/'
        EXPONENT='**'
        NOT='!'
        ASSIGN='='
        TO='=>'
        EQ='=='
        NEQ='!='
        INC='++'
        DEC='--'
        PLUS_ASSIGN='+='
        MINUS_ASSIGN='-='
        MULT_ASSIGN='*='
        DIV_ASSIGN='/='
        OR_ASSIGN='|='
        XOR_ASSIGN='^='
        AND_ASSIGN='&='
        LSHIFT_ASSIGN='<<='
        RSHIFT_ASSIGN='>>='
        PERCENT_ASSIGN='%='
        LESS='<'
        LESSEQ='<='
        MORE='>'
        MOREEQ='>='
        CARET='^'
        AND='&'
        ANDAND='&&'
        OR='|'
        OROR='||'
        LBRACKET='['
        RBRACKET=']'
        LBRACE='{'
        RBRACE='}'
        LPAREN='('
        RPAREN=')'
    ]

    extends(".*Expression")=Expression
    extends(".*TypeName")=TypeName
}

SourceUnit ::= (
        FunctionDefinition
        | ConstantVariableDeclaration
    )*
private UntilSemicolonRecover ::= !(';')
private UntilBraceRecover ::= !('}')

ConstantIdentifier ::= IDENTIFIER
ConstantVariableDeclaration ::= 'global' TypeName ConstantIdentifier ('=' Expression)? ';'

Placeholder ::= '_'
ReturnDef ::=
    TypeName |
    TypeNameList |
    '[' ( TypeName (',' TypeName)* )? ']' |
    Placeholder {
    mixin = "com.github.andreypfau.intellijton.func.psi.FuncReturnDefMixin"
}

ParameterIdentifier ::= IDENTIFIER
ParameterDef ::= TypeName ParameterIdentifier? {
    mixin = "com.github.andreypfau.intellijton.func.psi.FuncParameterDefMixin"
}
ParameterList ::= '(' ( ParameterDef (',' ParameterDef)* )? ')'

FunctionIdentifier ::= IDENTIFIER
AsmInstruction ::= StringLiteral
FunctionSpecifiers ::= 'impure' | 'inline' | 'inline_ref'
DefinedMethodId ::= 'method_id' '(' NumberLiteral ')'  { pin = 2}
MethodId ::=  DefinedMethodId | 'method_id'
FunctionDefinition ::= ReturnDef FunctionIdentifier ParameterList FunctionSpecifiers* MethodId?
((ASM AsmInstruction* )? ';' | Block ) {
    pin = 2
    mixin = "com.github.andreypfau.intellijton.func.psi.FuncFunctionDefinitionMixin"
    implements = "com.github.andreypfau.intellijton.func.psi.FuncNamedElement"
}

DeclarationIdentifier ::= IDENTIFIER
DeclarationItem ::= DeclarationIdentifier ','? | ','
DeclarationList ::= '(' DeclarationItem*    ')'
TypedDeclarationItem ::= (TypeName)? DeclarationIdentifier ','? | ','
TypedDeclarationList ::= '(' TypedDeclarationItem*    ')'

TypeNameItem ::= TypeName ','? | ','
TypeNameList ::= '(' TypeNameItem* ')'

VariableIdentifier ::= IDENTIFIER
VariableDeclaration ::=
        DeclarationList |
        TypedDeclarationList |
        TypeNameList VariableIdentifier |
        TypeName VariableIdentifier |
        TypeName TypedDeclarationList

TypeName ::= PrimitiveTypeName

private UnfinishedBlock ::= '{' (Statement)* {
        pin = 1
        recoverWhile = UntilBraceRecover
}
Block ::= UnfinishedBlock '}'

private FinishedStatement ::= SimpleStatement | ReturnSt  {
    recoverWhile = UntilSemicolonRecover
}
Statement ::=
    IfStatement
    | IfNotStatement
    | WhileStatement
    | DoUntilStatement
    | RepeatStatement
    | Block
    | ReturnTupleStatement
    | FinishedStatement ';'

ReturnTupleStatement ::= return SeqExpression ';'

private ExpressionStatement ::= Expression
private ConditionExpression ::= ('(' Expression ')' | Expression)
IfStatement ::= if ConditionExpression Block (( elseif ConditionExpression Block ( (elseifnot ConditionExpression Block (else Block)? ) | else Block)? ) | ( else Block ))? {pin=1}
IfNotStatement ::= ifnot ('(' Expression ')' | Expression) Block ( else Block )? {pin=1}
WhileStatement ::= while ('(' Expression ')' | Expression) Block {pin=1}
RepeatStatement ::= repeat ('(' Expression ')' | Expression) Block {pin=1}
private SimpleStatement ::= VariableDefinition | ExpressionStatement
DoUntilStatement ::= do Block until ('(' Expression ')' | Expression) {pin=1}
ReturnSt ::= return Expression? {pin=1}
SeqExpression ::= '(' (Expression ',')* Expression? ','* ')'
VariableDefinition ::= VariableDeclaration ( '=' Expression | SeqExpression )?

Expression ::=
    TernaryExpression
    | OrExpression
    | AndExpression
    | CompExpression
    | OrOpExpression
    | XorOpExpression
    | AndOpExpression
    | EqExpression
    | ShiftExpression
    | MultDivExpression
    | UnaryExpression
    | AssignmentExpression
    | HighestPriorityGroup
    | PlusMinExpression
    | InlineArrayExpression
    | PrimaryExpression {

    }

private HighestPriorityGroup ::=
    IndexAccessExpression
    | MemberAccessExpression
    | ModifierAccessExpression
    | SeqExpression
    | FunctionCallExpression

AssignmentExpression ::= Expression ('=' | '|=' | '^=' | '&=' | '<<=' | '>>=' | '+=' | '-=' | '*=' | '/=' | '%=') Expression
InlineArrayExpression ::= '[' Expression (',' Expression)* ']'
TernaryExpression ::= Expression '?' RightTernaryExpression
private RightTernaryExpression ::= Expression ':' Expression
OrExpression ::= Expression '||' Expression
AndExpression ::= Expression '&&' Expression
EqExpression ::= Expression ('==' | '!=') Expression
CompExpression ::= Expression ('<' | '>' | '<=' | '>=') Expression
OrOpExpression ::= Expression '|' Expression
XorOpExpression ::= Expression '^' Expression
AndOpExpression ::= Expression '&' Expression
ShiftExpression ::= Expression ('<<' | '>>') Expression
PlusMinExpression ::= Expression ('+' | '-') Expression
MultDivExpression ::= Expression ('*' | '/' | '%') Expression
UnaryExpression ::= ('!' | '~' |'+' | '-') Expression {pin=1}

PrimaryExpression ::= VarLiteral
    | BooleanLiteral
    | NumberLiteral
    | HexLiteral
    | StringLiteral
    | PrimitiveTypeNameExpression

VarLiteral ::= IDENTIFIER {
    mixin = "com.github.andreypfau.intellijton.func.psi.FuncVarLiteralMixin"
}
FunctionCallExpression ::= Expression FunctionInvocation {
    mixin = 'com.github.andreypfau.intellijton.func.psi.FuncFunctionCallMixin'
}
private FunctionInvocation ::= '(' FunctionCallArguments? ')'
FunctionCallArguments ::= Expression? ( ',' Expression )*
MemberAccessIdentifier ::= IDENTIFIER
MemberAccessExpression ::= Expression '.' MemberAccessIdentifier
ModifierAccessIdentifier ::= IDENTIFIER
ModifierAccessExpression ::= Expression '~' ModifierAccessIdentifier
IndexAccessExpression ::= Expression '[' ( Expression? ':' Expression? | Expression? ) ']' {pin=2}

BooleanLiteral ::= booleanLiteral
NumberLiteral ::= ( HexNumber | DecimalNumber )
private HexLiteral ::= hexLiteral
private StringLiteral ::= stringLiteral
private HexNumber ::= hexNumber
private DecimalNumber ::= decimalNumber

private PrimitiveTypeNameExpression ::= PrimitiveTypeName
PrimitiveTypeName ::= int | cell | slice | builder | tuple | cont | var
