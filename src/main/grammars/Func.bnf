{
  parserClass="com.github.andreypfau.intellijton.func.parser.FuncParser"
  parserUtilClass="com.github.andreypfau.intellijton.func.parser.FuncParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Func"
  psiImplClassSuffix="Impl"
  psiPackage="com.github.andreypfau.intellijton.func.psi"
  psiImplPackage="com.github.andreypfau.intellijton.func.psi.impl"

  elementTypeHolderClass="com.github.andreypfau.intellijton.func.psi.FuncTypes"
  elementTypeClass="com.github.andreypfau.intellijton.func.psi.FuncElementType"
  tokenTypeClass="com.github.andreypfau.intellijton.func.psi.FuncTokenType"

  tokens = [

    comment='regexp:(;;.*)|(\{-[\s\S]*?-})'
    stringLiteral='regexp:("([^"\r\n\\]|\\.)*")|unicode("([^"])*")'
    decimalNumber='regexp:([0-9][_0-9]*)'
    fixedNumber='regexp:(([0-9][_0-9]*)+\.[_0-9]*|([0-9][_0-9]*)*\.([0-9][_0-9]*))'
    scientificNumber='regexp:((([0-9][_0-9]*)+|([0-9][_0-9]*)+\.[_0-9]*|([0-9][_0-9]*|[0-9])*\.[_0-9]+)[Ee][+-]?[_0-9]+)'
    hexNumber='regexp:(0[xX][_0-9a-fA-F]+)'
    booleanLiteral='regexp:true|false'
    space='regexp:\s+'

    IDENTIFIER='regexp:[a-zA-Z_$][a-zA-Z_$0-9]*'

    DOT='.'
    COLON=':'
    SEMICOLON=';'
    COMMA=','
    PLUS='+'
    MINUS='-'
    MULT='*'
    DIV='/'
    EXPONENT='**'
    NOT='!'
    ASSIGN='='
    TO='=>'
    EQ='=='
    NEQ='!='
    INC='++'
    DEC='--'
    PLUS_ASSIGN='+='
    MINUS_ASSIGN='-='
    MULT_ASSIGN='*='
    DIV_ASSIGN='/='
    OR_ASSIGN='|='
    XOR_ASSIGN='^='
    AND_ASSIGN='&='
    LSHIFT_ASSIGN='<<='
    RSHIFT_ASSIGN='>>='
    PERCENT_ASSIGN='%='
    LESS='<'
    LESSEQ='<='
    MORE='>'
    MOREEQ='>='
    CARET='^'
    AND='&'
    ANDAND='&&'
    OR='|'
    OROR='||'
    LBRACKET='['
    RBRACKET=']'
    LBRACE='{'
    RBRACE='}'
    LPAREN='('
    RPAREN=')'
    QUESTION='?'
    PERCENT='%'
    TILDE='~'
    LSHIFT='<<'
    RSHIFT='>>'
    LEFT_ASSEMBLY=':='
    RIGHT_ASSEMBLY='=:'
    NAT_SPEC_TAG='regexp:@[a-zA-Z_0-9:]*'
  ]

  extends(".*Expression")=Expression
  extends(".*TypeName")=TypeName
}

SourceUnit ::= (
    FunctionDefinition
    | ConstantVariableDeclaration
    | Expression
  )*

private UntilSemicolonRecover ::= !(';')
private UntilBraceRecover ::= !(RBRACE)

ConstantIdentifier ::= IDENTIFIER
ConstantVariableDeclaration ::= 'global' TypeName ConstantIdentifier ('=' Expression)? ';'

ReturnDef ::=
    TypeName |
    LPAREN ( TypeName (COMMA TypeName)* )? RPAREN |
    LBRACKET ( TypeName (COMMA TypeName)* )? RBRACKET |
    '_'

ParameterIdentifier ::= IDENTIFIER
ParameterDef ::= TypeName ParameterIdentifier?
ParameterList ::= LPAREN ( ParameterDef (COMMA ParameterDef)* )? RPAREN

FunctionIdentifier ::= IDENTIFIER
FunctionDefinition ::= ReturnDef FunctionIdentifier ParameterList FunctionSpecifiers* ( ';' | Block ) { pin = 2 }

DeclarationIdentifier ::= IDENTIFIER
DeclarationItem ::= DeclarationIdentifier COMMA? | COMMA
DeclarationList ::= LPAREN DeclarationItem*  RPAREN
TypedDeclarationItem ::= (TypeName)? DeclarationIdentifier COMMA? | COMMA
TypedDeclarationList ::= LPAREN TypedDeclarationItem*  RPAREN

TypedItem ::= TypeName COMMA? | COMMA
TypedList ::= LPAREN TypedItem* RPAREN

VariableIdentifier ::= IDENTIFIER
VariableDeclaration ::=
    DeclarationList |
    TypedDeclarationList |
    TypedList VariableIdentifier |
    TypeName VariableIdentifier

TypeName ::=  PrimitiveTypeName

FunctionSpecifiers ::= impure | inline | inline_ref | method_id

private UnfinishedBlock ::= LBRACE (Statement)* {
    pin = 1
    recoverWhile = UntilBraceRecover
}
Block ::= UnfinishedBlock RBRACE

private FinishedStatement ::=
    DoUntilStatement
    | ReturnSt
    | SimpleStatement {
    recoverWhile = UntilSemicolonRecover
}
Statement ::= IfStatement | IfNotStatement | WhileStatement | RepeatStatement | Block | ReturnTupleStatement | FinishedStatement ';'

ReturnTupleStatement ::= return SeqExpression ';'

private ExpressionStatement ::= Expression
IfStatement ::= if LPAREN Expression RPAREN Block ( else Block )? {pin=1}
IfNotStatement ::= ifnot LPAREN Expression RPAREN Block ( else Block )? {pin=1}
WhileStatement ::= while LPAREN Expression RPAREN Block {pin=1}
RepeatStatement ::= repeat LPAREN Expression RPAREN Block {pin=1}
private SimpleStatement ::= VariableDefinition | ExpressionStatement
DoUntilStatement ::= do Block until LPAREN Expression RPAREN {pin=1}
ReturnSt ::= return Expression? {pin=1}
SeqExpression ::= LPAREN (Expression COMMA)* Expression? COMMA* RPAREN
VariableDefinition ::= VariableDeclaration ( '=' Expression | SeqExpression )?

Expression ::=
  TernaryExpression
  | OrExpression
  | AndExpression
  | CompExpression
  | OrOpExpression
  | XorOpExpression
  | AndOpExpression
  | EqExpression
  | ShiftExpression
  | MultDivExpression
  | HighestPriorityGroup
  | AssignmentExpression
  | PlusMinExpression
  | InlineArrayExpression
  | PrimaryExpression

private HighestPriorityGroup ::=
                      IndexAccessExpression
                      | MemberAccessExpression
                      | ModifierAccessExpression
                      | FunctionCallExpression
                      | SeqExpression

AssignmentExpression ::= Expression ('=' | '|=' | '^=' | '&=' | '<<=' | '>>=' | '+=' | '-=' | '*=' | '/=' | '%=') Expression
InlineArrayExpression ::= LBRACKET Expression (COMMA Expression)* RBRACKET
TernaryExpression ::= Expression '?' RightTernaryExpression
private RightTernaryExpression ::= Expression ':' Expression
OrExpression ::= Expression '||' Expression
AndExpression ::= Expression '&&' Expression
EqExpression ::= Expression ('==' | '!=') Expression
CompExpression ::= Expression ('<' | '>' | '<=' | '>=') Expression
OrOpExpression ::= Expression '|' Expression
XorOpExpression ::= Expression '^' Expression
AndOpExpression ::= Expression '&' Expression
ShiftExpression ::= Expression ('<<' | '>>') Expression
PlusMinExpression ::= Expression ('+' | '-') Expression
MultDivExpression ::= Expression ('*' | '/' | '%') Expression

PrimaryExpression ::= VarLiteral
                  | BooleanLiteral
                  | NumberLiteral
                  | HexLiteral
                  | StringLiteral
                  | PrimitiveTypeNameExpression

VarLiteral ::= IDENTIFIER
FunctionCallExpression ::= Expression FunctionInvocation
private FunctionInvocation ::= LPAREN FunctionCallArguments? RPAREN
FunctionCallArguments ::= Expression? ( COMMA Expression )*
MemberAccessIdentifier ::= IDENTIFIER
MemberAccessExpression ::= Expression '.' MemberAccessIdentifier
ModifierAccessIdentifier ::= IDENTIFIER
ModifierAccessExpression ::= Expression '~' ModifierAccessIdentifier
IndexAccessExpression ::= Expression LBRACKET ( Expression? ':' Expression? | Expression? ) RBRACKET {pin=2}

BooleanLiteral ::= booleanLiteral
NumberLiteral ::= ( HexNumber | DecimalNumber | FixedNumber | ScientificNumber)
private HexLiteral ::= hexLiteral
private StringLiteral ::= stringLiteral
private HexNumber ::= hexNumber
private FixedNumber ::= fixedNumber
private DecimalNumber ::= decimalNumber
private ScientificNumber ::= scientificNumber

private PrimitiveTypeNameExpression ::= PrimitiveTypeName
PrimitiveTypeName ::= int | cell | slice | builder | tuple | cont | var
