{
    parserClass="com.github.andreypfau.intellijton.fift.parser.FiftParser"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="Fift"
    psiImplClassSuffix="Impl"
    psiPackage="com.github.andreypfau.intellijton.fift.psi"
    psiImplPackage="com.github.andreypfau.intellijton.fift.psi.impl"

    elementTypeHolderClass="com.github.andreypfau.intellijton.fift.psi.FiftTypes"
    elementTypeClass="com.github.andreypfau.intellijton.fift.psi.FiftElementType"
    tokenTypeClass="com.github.andreypfau.intellijton.fift.psi.FiftTokenType"
    
    tokens = [
        SPACE='regexp:\s+'
        STRING_LITERAL='regexp:("([^"\r\n\\]|\\.)*")'
        NUMBER_DIGIT_LITERAL='regexp:(-?[0-9]+(/-?[0-9]+)?)'
        NUMBER_HEX_LITERAL='regexp:(0[xX][0-9a-fA-F]+)'
        NUMBER_BINARY_LITERAL='regexp:(0[bB][01]+)'
        SLICE_BINARY_LITERAL='regexp:(b\{[01]+})'
        SLICE_HEX_LITERAL='regexp:(x\{[0-9a-fA-F_]+})'
        BYTE_HEX_LITERAL='regexp:(B\{[0-9a-fA-F_]+})'
        LBRACKET='['
        RBRACKET=']'
        LBRACE='{'
        RBRACE='}'
        LPAREN='('
        RPAREN=')'
        STACK_WORD='regexp:(dup|drop|swap|rot|-rot|over|tuck|nip|2dup|2drop|2swap|pick|roll|-roll|exch|exch2|\?dup)(\s|\Z)'
        CONDITION_WORD='regexp:(if|ifnot|cond)(\s|\Z)'
        LOOP_WORD='regexp:(until|while|times)(\s|\Z)'
        INCLUDE_WORD='include'
        WORD='regexp:\S+'
        STRING_WORD='regexp:(\S+"[^"]*"(\s|\n|\Z))'
        COMMENT='regexp:(//.*)|(#.*)|(/\*[\s\S]*?\*/)'
    ]
    extends(".*Literal") = Literal
}

Root ::= (Statement*)
Statement ::= Include | Declaration | Block | Literal | WordStatement

WordStatement ::= STACK_WORD | CONDITION_WORD | LOOP_WORD | WORD | STRING_WORD
Declaration ::= Block ':' WORD
Include ::= STRING_LITERAL INCLUDE_WORD

NumberLiteral ::= NUMBER_DIGIT_LITERAL | NUMBER_HEX_LITERAL | NUMBER_BINARY_LITERAL
Literal ::= STRING_LITERAL | NumberLiteral | SliceLiteral | ByteLiteral
SliceLiteral ::= SLICE_BINARY_LITERAL | SLICE_HEX_LITERAL
ByteLiteral ::= BYTE_HEX_LITERAL

private UntilBraceRecover ::= !('}')
private UnfinishedBlock ::= '{' (Statement)* {
        pin = 1
        recoverWhile = UntilBraceRecover
}
Block ::= UnfinishedBlock '}'
