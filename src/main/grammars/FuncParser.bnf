{
    parserClass="org.ton.intellij.func.lexer.FuncParser"
    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="Func"
    psiImplClassSuffix="Impl"
    psiPackage="org.ton.intellij.func.psi"
    psiImplPackage="org.ton.intellij.func.psi.impl"
    implements="org.ton.intellij.func.psi.FuncElement"

    elementTypeHolderClass="org.ton.intellij.func.psi.FuncTokenTypes"
    elementTypeClass="org.ton.intellij.func.psi.FuncElementType"
    tokenTypeClass="org.ton.intellij.func.psi.FuncTokenType"

    tokens = [
        PLUS='+'
        MINUS='-'
        TIMES='*'
        DIVIDE='/'
        PERCENT='%'
        QUESTION='?'
        COLON=':'
        COMMA=','
        DOT='.'
        SEMICOLON=';'
        LPAREN='('
        RPAREN=')'
        LBRACKET='['
        RBRACKET=']'
        LBRACE='{'
        RBRACE='}'
        EQUALS='='
        LESS='<'
        GREATER='>'
        AND='&'
        OR='|'
        CIRCUMFLEX='^'
        TILDE='~'
        UNDERSCORE='_'

        EQ='=='
        NEQ='!='
        LEQ='<='
        GEQ='>='
        SPACESHIP='<=>'
        LSHIFT='<<'
        RSHIFT='>>'
        RSHIFTR='~>>'
        RSHIFTC='^>>'
        DIVR='~/'
        DIVC='^/'
        MODR='~%'
        MODC='^%'
        DIVMOD='/%'
        PLUSLET='+='
        MINUSLET='-='
        TIMESLET='*='
        DIVLET='/='
        DIVRLET='~/='
        DIVCLET='^/='
        MODLET='%='
        MODRLET='~%='
        MODCLET='^%='
        LSHIFTLET='<<='
        RSHIFTLET='>>='
        RSHIFTRLET='~>>='
        RSHIFTCLET='^>>='
        ANDLET='&='
        ORLET='|='
        XORLET='^='
        ARROW='->'

        RETURN='return'
        VAR='var'
        REPEAT='repeat'
        DO='do'
        WHILE='while'
        UNTIL='until'
        IF='if'
        IFNOT='ifnot'
        THEN='then'
        ELSE='else'
        ELSEIF='elseif'
        ELSEIFNOT='elseifnot'

        INT='int'
        CELL='cell'
        SLICE='slice'
        BUILDER='builder'
        CONT='cont'
        TUPLE='tuple'
        TYPE='type'
        MAPSTO='->'
        FORALL='forall'
        TRUE='true'
        FALSE='false'

        EXTERN='extern'
        GLOBAL='global'
        ASM='asm'
        IMPURE='impure'
        INLINE='inline'
        INLINE_REF='inline_ref'
        AUTO_APPLY='auto_apply'
        METHOD_ID='method_id'
        OPERATOR='operator'
        INFIXL='infixl'
        INFIXR='infixr'
        CONST='const'

        PRAGMA='#pragma'
        VERSION='version'
        NOT_VERSION='not-version'
        TEST_VERSION_SET='test-version-set'
        INCLUDE='#include'

        WHITE_SPACE='regexp:\s+'
        LINE_COMMENT="regexp:;;.*"
        BLOCK_COMMENT="regexp:\{-(.|\n)*-}"
        INTEGER_LITERAL='regexp:(-?[0-9][_0-9]*)|(0[xX][_0-9a-fA-F]+)|(0[bB][_0-1]+)'
        STRING_LITERAL='regexp:(\"([^\"\r\n\\]|\\.)*\")[sauhHc]?'
        IDENTIFIER="regexp:`.*`|[a-zA-Z_][^\s\+\-\*\/\%\,\.\;\(\)\{\}\[\]\=\<\>\|\^\~]*"
    ]
}

private root ::= (macro | global_var_expression | const_expression | function)*
private UntilSemicolonRecover ::= !(';')
private UntilBraceRecover ::= !('}')
private UntilParenRecover ::= !(')')

macro ::= (pragma_directive | include_directive)

private pragma_directive_begin ::= PRAGMA (pragma_version | pragma_not_version | pragma_test_version_set) {
    pin = 1
    recoverWhile = UntilSemicolonRecover
}
pragma_directive ::= pragma_directive_begin ';'

IncludePath ::= STRING_LITERAL {
    implements = "org.ton.intellij.func.psi.FuncNamedElement"
    mixin = "org.ton.intellij.func.psi.FuncIncludePathMixin"
    stubClass = "org.ton.intellij.func.stub.FuncIncludePathStub"
    elementTypeFactory = "org.ton.intellij.func.stub.StubKt.factory"
}
private include_directive_part ::= INCLUDE IncludePath {
    pin = 1
    recoverWhile = UntilSemicolonRecover
}
include_directive ::= include_directive_part ';'

pragma_version ::= VERSION version_directive {pin=1}
pragma_not_version ::= NOT_VERSION version_directive {pin=1}
pragma_test_version_set ::= TEST_VERSION_SET STRING_LITERAL {pin=1}
version_directive ::= ('>' | '<' | '<=' | '>=' | '^' | '=' )? INTEGER_LITERAL ('.' INTEGER_LITERAL)* {pin=2}

function ::= type_variables_list? function_return_type function_name parameter_list
             'impure'? ('inline' | 'inline_ref')? method_id_specifier? (function_body | ';') {
    pin = 3;
    implements = "org.ton.intellij.func.psi.FuncNamedElement"
    mixin = "org.ton.intellij.func.psi.FuncFunctionDefinitionMixin"
    stubClass = "org.ton.intellij.func.stub.FuncFunctionStub"
    elementTypeClass = "org.ton.intellij.func.stub.FuncFunctionStub.Type"
    elementTypeFactory = "org.ton.intellij.func.stub.StubKt.factory"
}
function_body ::= block_statement | asm_function_body

function_return_type ::= type

type_variables_list ::= 'forall' type_identifier (',' type_identifier)* '->' {pin=1}

private method_id_specifier_id_begin ::= '(' INTEGER_LITERAL {
    pin = 1
    recoverWhile = UntilParenRecover
}
method_id_specifier_id ::= method_id_specifier_id_begin ')'
method_id_specifier ::= 'method_id' method_id_specifier_id? {pin=1}

asm_function_body ::= asm_specifier asm_instruction+ ';' {pin=1}
asm_specifier ::= 'asm' ('(' IDENTIFIER* ('->'  INTEGER_LITERAL*)? ')')? {pin=1}
asm_instruction ::= STRING_LITERAL

private parameter_list_begin ::= '(' parameter_list_item* {pin=1; recoverWhile=UntilParenRecover}
private parameter_list_item ::= UntilParenRecover parameter_declaration (',' | &')' ) { pin=2 }
parameter_declaration ::= (type IDENTIFIER) | IDENTIFIER {
   implements = "org.ton.intellij.func.psi.FuncNamedElement"
   mixin = "org.ton.intellij.func.psi.FuncParameterDeclarationMixin"
}
parameter_list ::= parameter_list_begin ')' {
    mixin = "org.ton.intellij.func.psi.FuncFunctionParameterListMixin"
}

global_var_expression ::= 'global' global_var (',' global_var)* ';' {pin=1}
global_var ::= type IDENTIFIER {
    implements = "org.ton.intellij.func.psi.FuncNamedElement"
    mixin = "org.ton.intellij.func.psi.FuncGlobalVarMixin"
}
private const_list_item ::= const_declaration (',' | &';')
private const_list ::= const_list_item+ {recoverWhile=UntilSemicolonRecover}
const_declaration ::= primitive_type? IDENTIFIER '=' expression {
    implements = "org.ton.intellij.func.psi.FuncNamedElement"
    mixin = "org.ton.intellij.func.psi.FuncConstDeclarationMixin"
}
const_expression ::= const const_list ';' {pin=1}

//
// STATEMENTS
//

private statement ::= return_statement | block_statement | empty_statement | repeat_statement |
                      if_statement | do_statement | while_statement | expression_statement
private block_statement_item ::= UntilBraceRecover statement* { recoverWhile=UntilBraceRecover }
block_statement ::= '{' block_statement_item* '}'

return_statement ::= 'return' expression ';' {pin=1}
expression_statement ::= expression ';' {pin=1}
empty_statement ::= ';'
repeat_statement ::= 'repeat' expression block_statement {pin=1}
if_statement ::= ('if' | 'ifnot') expression block_statement (else_statement | elseif_statement | elseifnot_statement)? {pin=1}
elseif_statement ::= 'elseif' expression block_statement (else_statement | elseif_statement | elseifnot_statement)? {pin=1}
elseifnot_statement ::= 'elseifnot' expression block_statement (else_statement | elseif_statement | elseifnot_statement)? {pin=1}
else_statement ::= 'else' block_statement {pin=1}
do_statement ::= 'do' block_statement 'until' expression {pin=1}
while_statement ::= 'while' expression block_statement {pin=1}

//
// EXPRESSIONS
//

expression ::= assignment_expression
assignment_expression ::= ternary_expression (('=' | '+=' | '-=' | '*=' | '/=' | '~/=' | '^/=' | '%=' | '~%=' | '^%=' | '<<=' | '>>=' | '~>>=' | '^>>=' | '&=' | '|=' | '^=') assignment_expression)?
ternary_expression ::= equation_expression ('?' expression ':' ternary_expression)?
equation_expression ::= bitwise_expression (('==' | '<' | '>' | '<=' | '>=' | '!=' | '<=>') bitwise_expression)?
bitwise_expression ::= arithmetic_expression (('<<' | '>>' | '~>>' | '^>>') arithmetic_expression)*
arithmetic_expression ::= '-'? expr30 (('-' | '+' | '|' | '^') expr30)*
expr30 ::= expr75 (('*' | '/' | '%' | '~/' | '^/' | '~%' | '^%' | '/%' | '&') expr75)*
expr75 ::= '~'? expr80
expr80 ::= expr90 callable*
expr90 ::= variable_declaration | function_call | expr100
expr100 ::= (type_expression | non_type_expression)
non_type_expression ::= (tensor_expression | tuple_expression | primitive_type | INTEGER_LITERAL | STRING_LITERAL | boolean_literal | reference_expression)

reference_expression ::= IDENTIFIER {
    implements = "org.ton.intellij.func.psi.FuncNamedElement"
    mixin = "org.ton.intellij.func.psi.FuncReferenceExpressionMixin"
}

callable ::= method_call | modifying_method_call

method_call ::= '.' method_call_identifier tensor_expression {
    pin = 1
    implements = "org.ton.intellij.func.psi.FuncNamedElement"
    mixin = "org.ton.intellij.func.psi.FuncMethodCallMixin"
}
method_call_identifier ::= IDENTIFIER {
    implements = "org.ton.intellij.func.psi.FuncNamedElement"
    mixin = "org.ton.intellij.func.psi.FuncMethodCallIdentifierMixin"
}

modifying_method_call ::= '~' modifying_method_call_identifier tensor_expression {
    implements = "org.ton.intellij.func.psi.FuncNamedElement"
    mixin = "org.ton.intellij.func.psi.FuncModifyingMethodCallMixin"
}
modifying_method_call_identifier ::= IDENTIFIER {
    implements = "org.ton.intellij.func.psi.FuncNamedElement"
    mixin = "org.ton.intellij.func.psi.FuncModifyingMethodCallIdentifierMixin"
}

variable_declaration ::= type_expression (IDENTIFIER | tuple_expression | tensor_expression) {
    implements = "org.ton.intellij.func.psi.FuncNamedElement"
    mixin = "org.ton.intellij.func.psi.FuncVariableDeclarationMixin"
}
function_call ::= function_call_identifier tensor_expression {
    implements = "org.ton.intellij.func.psi.FuncNamedElement"
    mixin = "org.ton.intellij.func.psi.FuncFunctionCallMixin"
}
function_call_identifier ::= IDENTIFIER {
    implements = "org.ton.intellij.func.psi.FuncNamedElement"
    mixin = "org.ton.intellij.func.psi.FuncFunctionCallIdentifierMixin"
}

type_expression ::= primitive_type | var_type | parenthesized_type_expression | tensor_type_expression | tuple_type_expression
parenthesized_type_expression ::= '(' type_expression ')'
tensor_type_expression_item ::= !')' type_expression (','|&')')
tensor_type_expression ::= '(' tensor_type_expression_item* ')'
tuple_type_expression_item ::= !']' type_expression (','|&']')
tuple_type_expression ::= '[' tuple_type_expression_item* ']'

tensor_expression_item ::= !')' expression (','|&')')
tensor_expression ::= '(' tensor_expression_item* ')'
tuple_expression_item ::= !']' expression (','|&']')
tuple_expression ::= '[' tuple_expression_item* ']'

//
// TYPES
//

private type ::= function_type | atomic_type
private atomic_type ::= primitive_type | var_type | hole_type | tensor_type | tuple_type | type_identifier
primitive_type ::= 'int' | 'cell' | 'slice' | 'builder' | 'cont' | 'tuple'
var_type ::= 'var'
hole_type ::= '_'

private tensor_type_item_recovery ::= !')'
private tensor_type_start ::= '(' tensor_type_item* {pin=1 recoverWhile=tensor_type_item_recovery}
tensor_type ::= tensor_type_start ')'
tensor_type_item ::= type ( ','| &')' ) {pin=1}

private tuple_type_item_recovery ::= !']'
private tuple_type_start ::= '[' tuple_type_item* {pin=1 recoverWhile=tuple_type_item_recovery}
tuple_type ::= tuple_type_start ']'
tuple_type_item ::= type ( ','| &']' ) {pin=1}

function_type ::= atomic_type '->' atomic_type {pin=2}

//
// LITERALS
//

boolean_literal ::= 'true' | 'false'
function_name ::= '~'? IDENTIFIER {
    mixin = "org.ton.intellij.func.psi.FuncFunctionNameMixin"
}
type_identifier ::= IDENTIFIER

//noinspection BnfUnusedRule
private unused_in_bnf ::= LINE_COMMENT | BLOCK_COMMENT | LINE_DOCUMENTATION | BLOCK_DOCUMENTATION