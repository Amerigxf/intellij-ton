{
    parserClass="com.github.andreypfau.intellijton.func.lexer.FuncParser"
    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="Func"
    psiImplClassSuffix="Impl"
    psiPackage="com.github.andreypfau.intellijton.func.psi"
    psiImplPackage="com.github.andreypfau.intellijton.func.psi.impl"
    implements="com.github.andreypfau.intellijton.func.psi.FuncElement"

    elementTypeHolderClass="com.github.andreypfau.intellijton.func.psi.FuncTypes"
    elementTypeClass="com.github.andreypfau.intellijton.func.psi.FuncElementType"
    tokenTypeClass="com.github.andreypfau.intellijton.func.psi.FuncTokenType"

    tokens = [
        PLUS='+'
        MINUS='-'
        TIMES='*'
        DIVIDE='/'
        PERCENT='%'
        QUESTION='?'
        COLON=':'
        COMMA=','
        DOT='.'
        SEMICOLON=';'
        LPAREN='('
        RPAREN=')'
        LBRACKET='['
        RBRACKET=']'
        LBRACE='{'
        RBRACE='}'
        EQUALS='='
        LESS='<'
        GREATER='>'
        AND='&'
        OR='|'
        CIRCUMFLEX='^'
        TILDE='~'

        EQ='=='
        NEQ='!='
        LEQ='<='
        GEQ='>='
        SPACESHIP='<=>'
        LSHIFT='<<'
        RSHIFT='>>'
        RSHIFTR='~>>'
        RSHIFTC='^>>'
        DIVR='~/'
        DIVC='^/'
        MODR='~%'
        MODC='^%'
        DIVMOD='/%'
        PLUSLET='+='
        MINUSLET='-='
        TIMESLET='*='
        DIVLET='/='
        DIVRLET='~/='
        DIVCLET='^/='
        MODLET='%='
        MODRLET='~%='
        MODCLET='^%='
        LSHIFTLET='<<='
        RSHIFTLET='>>='
        RSHIFTRLET='~>>='
        RSHIFTCLET='^>>='
        ANDLET='&='
        ORLET='|='
        XORLET='^='

        RETURN='return'
        VAR='var'
        REPEAT='repeat'
        DO='do'
        WHILE='while'
        UNTIL='until'
        IF='if'
        IFNOT='ifnot'
        THEN='then'
        ELSE='else'
        ELSEIF='elseif'
        ELSEIFNOT='elseifnot'

        INT='int'
        CELL='cell'
        SLICE='slice'
        BUILDER='builder'
        CONT='cont'
        TUPLE='tuple'
        TYPE='type'
        MAPSTO='->'
        FORALL='forall'
        TRUE='true'
        FALSE='false'

        EXTERN='extern'
        GLOBAL='global'
        ASM='asm'
        IMPURE='impure'
        INLINE='inline'
        INLINE_REF='inline_ref'
        AUTO_APPLY='auto_apply'
        METHOD_ID='method_id'
        OPERATOR='operator'
        INFIXL='infixl'
        INFIXR='infixr'

        WHITE_SPACE='regexp:\s+'
        LINE_COMMENT="regexp:;;.*"
        BLOCK_COMMENT="regexp:\{-(.|\n)*-}"
        INTEGER_LITERAL='regexp:(-?[0-9][_0-9]*)|(0[xX][_0-9a-fA-F]+)|(0[bB][_0-1]+)'
        STRING_LITERAL='regexp:("([^"\r\n\\]|\\.)*")|unicode("([^"])*")'
        IDENTIFIER="regexp:(`.*`)|(([a-zA-Z_](\w|['?:])+)|([a-zA-Z]))"
    ]
}

private root ::= (global_var_declaration | function)*
function ::= type_variables_list? function_return_type function_name parameter_list
             'impure'? inline_specifier? method_id_specifier? (';' | block_statement | asm_function_body) {
    implements = "com.github.andreypfau.intellijton.func.psi.FuncNamedElement"
    mixin = "com.github.andreypfau.intellijton.func.psi.FuncFunctionDefinitionMixin"
    stubClass = "com.github.andreypfau.intellijton.func.stub.FuncFunctionStub"
    elementTypeClass = "com.github.andreypfau.intellijton.func.stub.FuncFunctionStub.Type"
    elementTypeFactory = "com.github.andreypfau.intellijton.func.stub.StubKt.factory"
}
function_return_type ::= type

type_variables_list ::= 'forall' type_identifier (',' type_identifier)* '->' {pin=1}
inline_specifier ::= 'inline' | 'inline_ref'
method_id_specifier ::= 'method_id' ('('  INTEGER_LITERAL ')')? {pin=1}

asm_function_body ::= asm_specifier asm_instruction+ ';'
asm_specifier ::= 'asm' ('(' IDENTIFIER* ('->'  INTEGER_LITERAL*)? ')')? {pin=1}
asm_instruction ::= STRING_LITERAL

private parameter_list_recovery ::= !')'
private parameter_list_begin ::= '(' parameter_list_item* {recoverWhile=parameter_list_recovery}
private parameter_list_item ::= !')' parameter_declaration (',' | &')' ) { pin=2 }
parameter_declaration ::= (type (IDENTIFIER | '_')) | IDENTIFIER | '_'
parameter_list ::= parameter_list_begin ')'

global_var_declaration ::= 'global' global_var (',' global_var)* ';' {pin=1}
global_var ::= (type IDENTIFIER) | IDENTIFIER

//
// STATEMENTS
//

private statement ::= return_statement | block_statement | empty_statement | repeat_statement |
                      if_statement | do_statement | while_statement | expression_statement
private block_statement_recovery ::= !'}'
private block_statement_item ::= !'}' statement* { recoverWhile=block_statement_recovery }
block_statement ::= '{' block_statement_item* '}'

return_statement ::= 'return' expression ';' {pin=1}
expression_statement ::= expression ';' {pin=1}
empty_statement ::= ';'
repeat_statement ::= 'repeat' expression block_statement {pin=1}
if_statement ::= ('if' | 'ifnot') expression block_statement (else_statement | elseif_statement | elseifnot_statement)? {pin=1}
elseif_statement ::= 'elseif' expression block_statement (elseifnot_statement | else_statement)? {pin=1}
elseifnot_statement ::= 'elseifnot' expression block_statement else_statement? {pin=1}
else_statement ::= 'else' block_statement {pin=1}
do_statement ::= 'do' block_statement 'until' expression {pin=1}
while_statement ::= 'while' expression block_statement {pin=1}

//
// EXPRESSIONS
//

private expression ::= expr10
private expr10 ::= expr13 (('=' | '+=' | '-=' | '*=' | '/=' | '~/=' | '^/=' | '%=' | '~%=' | '^%=' | '<<=' | '>>=' | '~>>=' | '^>>=' | '&=' | '|=' | '^=') expr10)?
private expr13 ::= expr15 ('?' expression ':' expr13)?
private expr15 ::= expr17 (('==' | '<' | '>' | '<=' | '>=' | '!=' | '<=>') expr17)?
private expr17 ::= expr20 (('<<' | '>>' | '~>>' | '^>>') expr20)*
private expr20 ::= '-'? expr30 (('-' | '+' | '|' | '^') expr30)*
private expr30 ::= expr75 (('*' | '/' | '%' | '~/' | '^/' | '~%' | '^%' | '/%' | '&') expr75)*
private expr75 ::= '~'? expr80
private expr80 ::= expr90 (method_call)*
private expr90 ::= variable_declaration | function_call | expr100
private expr100 ::= (type_expression | nontype_expr100)
private nontype_expr100 ::= (tensor_expression | tuple_expression | unit_literal | primitive_type |  INTEGER_LITERAL | boolean_literal | '_' | IDENTIFIER)

method_call ::= (dot_method_call_identifier | tilda_method_call_identifier) expr100
dot_method_call_identifier ::= '.' IDENTIFIER {pin=1}
tilda_method_call_identifier ::= '~' IDENTIFIER {pin=1}

variable_declaration ::= type_expression (IDENTIFIER | tuple_expression | tensor_expression | unit_literal)
function_call ::= function_call_identifier (tensor_expression | unit_literal) {
    implements = "com.github.andreypfau.intellijton.func.psi.FuncNamedElement"
    mixin = "com.github.andreypfau.intellijton.func.psi.FuncFunctionCallMixin"
}
function_call_identifier ::= IDENTIFIER {
    implements = "com.github.andreypfau.intellijton.func.psi.FuncNamedElement"
    mixin = "com.github.andreypfau.intellijton.func.psi.FuncFunctionCallIdentifierMixin"
}

type_expression ::= primitive_type | var_type | parenthesized_type_expression | tensor_type_expression | tuple_type_expression
parenthesized_type_expression ::= '(' type_expression ')'
tensor_type_expression_item ::= !')' type_expression (','|&')')
tensor_type_expression ::= '(' tensor_type_expression_item+ ')'
tuple_type_expression_item ::= !']' type_expression (','|&']')
tuple_type_expression ::= '[' tuple_type_expression_item+ ']'

tensor_expression_item ::= !')' expression (','|&')')
tensor_expression ::= '(' tensor_expression_item+ ')'
tuple_expression_item ::= !']' expression (','|&']')
tuple_expression ::= '[' tuple_expression_item+ ']'

//
// TYPES
//

private type ::= function_type | atomic_type
private atomic_type ::= primitive_type | var_type | hole_type | unit_type | tensor_type | tuple_type | type_identifier
primitive_type ::= 'int' | 'cell' | 'slice' | 'builder' | 'cont' | 'tuple'
var_type ::= 'var'
hole_type ::= '_'
unit_type ::= unit_literal

private tensor_type_item_recovery ::= !')'
private tensor_type_start ::= '(' tensor_type_item+ {pin=1 recoverWhile=tensor_type_item_recovery}
tensor_type ::= tensor_type_start ')'
tensor_type_item ::= type ( ','| &')' ) {pin=1}

private tuple_type_item_recovery ::= !']'
private tuple_type_start ::= '[' tuple_type_item+ {pin=1 recoverWhile=tuple_type_item_recovery}
tuple_type ::= tuple_type_start ']'
tuple_type_item ::= type ( ','| &']' ) {pin=1}

function_type ::= atomic_type '->' atomic_type {pin=2}

//
// LITERALS
//

boolean_literal ::= 'true' | 'false'
function_name ::= '~'? IDENTIFIER
unit_literal ::= '(' ')'
type_identifier ::= IDENTIFIER

//noinspection BnfUnusedRule
private unused_in_bnf ::= LINE_COMMENT | BLOCK_COMMENT | LINE_DOCUMENTATION | BLOCK_DOCUMENTATION